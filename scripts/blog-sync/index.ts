import fetch from 'node-fetch';

// Types
interface SeobotIndex {
  articles: {
    id: string;
    title: string;
    slug: string;
    created_at: string;
    updated_at: string;
    excerpt?: string;
    tags?: string[];
  }[];
}

interface SeobotArticle {
  id: string;
  title: string;
  slug: string;
  content: string;
  created_at: string;
  updated_at: string;
  excerpt?: string;
  tags?: string[];
  meta?: {
    author?: string;
    description?: string;
  };
}

interface GitBookPage {
  id?: string;
  title: string;
  slug: string;
  content: string;
  parent?: string;
  type: 'page';
  visibility: 'public';
}

interface BlogSyncConfig {
  seobotApiKey: string;
  gitbookToken: string;
  gitbookSpaceId: string;
  gitbookBlogParentId: string;
  slackWebhookUrl?: string;
}

export interface BlogSyncResult {
  success: boolean;
  processed: number;
  created: number;
  updated: number;
  errors: string[];
  logs: string[];
}

// Cache for last sync times
const SYNC_CACHE_KEY = 'blog-sync-last-run';

export class BlogSyncService {
  private config: BlogSyncConfig;
  private logs: string[] = [];
  private errors: string[] = [];

  constructor(config: BlogSyncConfig) {
    this.config = config;
  }

  private log(message: string) {
    console.log(`[BlogSync] ${message}`);
    this.logs.push(message);
  }

  private error(message: string, error?: Error) {
    const errorMsg = error ? `${message}: ${error.message}` : message;
    console.error(`[BlogSync] ERROR: ${errorMsg}`);
    this.errors.push(errorMsg);
  }

  // Fetch SEObot article index
  private async fetchSeobotIndex(): Promise<SeobotIndex> {
    try {
      const response = await fetch('https://api.seobot.com/v1/articles', {
        headers: {
          'Authorization': `Bearer ${this.config.seobotApiKey}`,
          'Content-Type': 'application/json'
        }
      });

      if (!response.ok) {
        throw new Error(`SEObot API error: ${response.status} ${response.statusText}`);
      }

      const data = await response.json() as SeobotIndex;
      this.log(`Fetched ${data.articles.length} articles from SEObot index`);
      return data;
    } catch (error) {
      this.error('Failed to fetch SEObot index', error as Error);
      throw error;
    }
  }

  // Fetch individual SEObot article
  private async fetchSeobotArticle(articleId: string): Promise<SeobotArticle> {
    try {
      const response = await fetch(`https://api.seobot.com/v1/articles/${articleId}`, {
        headers: {
          'Authorization': `Bearer ${this.config.seobotApiKey}`,
          'Content-Type': 'application/json'
        }
      });

      if (!response.ok) {
        throw new Error(`SEObot API error: ${response.status} ${response.statusText}`);
      }

      return await response.json() as SeobotArticle;
    } catch (error) {
      this.error(`Failed to fetch SEObot article ${articleId}`, error as Error);
      throw error;
    }
  }

  // Clean content - remove SEObot attribution
  private cleanContent(content: string): string {
    // Remove any SEObot branding, attribution, or metadata
    let cleaned = content
      .replace(/<!-- SEObot.*?-->/gs, '')
      .replace(/\*\*Generated by SEObot.*?\*\*/gi, '')
      .replace(/\[SEObot\].*?\n/gi, '')
      .replace(/Source: SEObot.*?\n/gi, '')
      .replace(/---\s*\ngenerated_by:.*?\n---/gs, '')
      .replace(/seobot/gi, '')
      .trim();

    // Ensure no SEObot references remain
    cleaned = cleaned.replace(/\b(seo-?bot|seobot)\b/gi, '');
    
    return cleaned;
  }

  // Convert SEObot article to GitBook page format
  private articleToGitBookPage(article: SeobotArticle): GitBookPage {
    const cleanedContent = this.cleanContent(article.content);
    
    return {
      title: article.title,
      slug: article.slug,
      content: cleanedContent,
      parent: this.config.gitbookBlogParentId,
      type: 'page',
      visibility: 'public'
    };
  }

  // Get existing GitBook pages in blog section
  private async getGitBookBlogPages(): Promise<any[]> {
    try {
      const response = await fetch(
        `https://api.gitbook.com/v1/spaces/${this.config.gitbookSpaceId}/content`,
        {
          headers: {
            'Authorization': `Bearer ${this.config.gitbookToken}`,
            'Content-Type': 'application/json'
          }
        }
      );

      if (!response.ok) {
        throw new Error(`GitBook API error: ${response.status} ${response.statusText}`);
      }

      const data = await response.json();
      // Filter for blog pages under the specified parent
      const blogPages = data.pages?.filter((page: any) => 
        page.parent === this.config.gitbookBlogParentId
      ) || [];
      
      this.log(`Found ${blogPages.length} existing blog pages in GitBook`);
      return blogPages;
    } catch (error) {
      this.error('Failed to fetch GitBook blog pages', error as Error);
      throw error;
    }
  }

  // Create or update GitBook page
  private async upsertGitBookPage(page: GitBookPage, existingPageId?: string): Promise<{ created: boolean; id: string }> {
    try {
      const url = existingPageId 
        ? `https://api.gitbook.com/v1/spaces/${this.config.gitbookSpaceId}/content/pages/${existingPageId}`
        : `https://api.gitbook.com/v1/spaces/${this.config.gitbookSpaceId}/content/pages`;
      
      const method = existingPageId ? 'PUT' : 'POST';
      
      const response = await fetch(url, {
        method,
        headers: {
          'Authorization': `Bearer ${this.config.gitbookToken}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(page)
      });

      if (!response.ok) {
        throw new Error(`GitBook API error: ${response.status} ${response.statusText}`);
      }

      const result = await response.json();
      return {
        created: !existingPageId,
        id: result.id || existingPageId!
      };
    } catch (error) {
      this.error(`Failed to ${existingPageId ? 'update' : 'create'} GitBook page: ${page.title}`, error as Error);
      throw error;
    }
  }

  // Send Slack notification
  private async sendSlackNotification(result: BlogSyncResult) {
    if (!this.config.slackWebhookUrl) return;

    try {
      const message = {
        text: `Blog Sync Complete`,
        blocks: [
          {
            type: 'section',
            text: {
              type: 'mrkdwn',
              text: `*Blog Sync Results*\n\n• Processed: ${result.processed}\n• Created: ${result.created}\n• Updated: ${result.updated}\n• Errors: ${result.errors.length}`
            }
          }
        ]
      };

      if (result.errors.length > 0) {
        message.blocks.push({
          type: 'section',
          text: {
            type: 'mrkdwn',
            text: `*Errors:*\n${result.errors.slice(0, 5).map(e => `• ${e}`).join('\n')}`
          }
        });
      }

      await fetch(this.config.slackWebhookUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(message)
      });

      this.log('Slack notification sent');
    } catch (error) {
      this.error('Failed to send Slack notification', error as Error);
    }
  }

  // Main sync function
  async syncBlog(mode: 'backfill' | 'delta' = 'delta'): Promise<BlogSyncResult> {
    this.logs = [];
    this.errors = [];
    
    let processed = 0;
    let created = 0;
    let updated = 0;

    try {
      this.log(`Starting blog sync in ${mode} mode`);

      // Fetch SEObot index
      const seobotIndex = await this.fetchSeobotIndex();
      
      // Get existing GitBook pages
      const existingPages = await this.getGitBookBlogPages();
      const existingPageMap = new Map(existingPages.map(p => [p.slug, p]));

      // Filter articles based on mode
      let articlesToProcess = seobotIndex.articles;
      
      if (mode === 'delta') {
        // In delta mode, only process articles updated in last 24 hours
        const yesterday = new Date();
        yesterday.setDate(yesterday.getDate() - 1);
        
        articlesToProcess = seobotIndex.articles.filter(article => 
          new Date(article.updated_at) > yesterday
        );
        
        this.log(`Delta mode: processing ${articlesToProcess.length} articles updated since yesterday`);
      } else {
        this.log(`Backfill mode: processing all ${articlesToProcess.length} articles`);
      }

      // Process each article
      for (const article of articlesToProcess) {
        try {
          this.log(`Processing article: ${article.title}`);
          
          // Fetch full article content
          const fullArticle = await this.fetchSeobotArticle(article.id);
          
          // Convert to GitBook page format
          const gitbookPage = this.articleToGitBookPage(fullArticle);
          
          // Check if page already exists
          const existingPage = existingPageMap.get(article.slug);
          
          // Upsert the page
          const result = await this.upsertGitBookPage(gitbookPage, existingPage?.id);
          
          if (result.created) {
            created++;
            this.log(`Created new page: ${article.title}`);
          } else {
            updated++;
            this.log(`Updated existing page: ${article.title}`);
          }
          
          processed++;
          
          // Rate limiting - wait 100ms between requests
          await new Promise(resolve => setTimeout(resolve, 100));
          
        } catch (error) {
          this.error(`Failed to process article: ${article.title}`, error as Error);
          // Continue processing other articles
        }
      }

      const result: BlogSyncResult = {
        success: this.errors.length === 0,
        processed,
        created,
        updated,
        errors: this.errors,
        logs: this.logs
      };

      this.log(`Blog sync completed: ${processed} processed, ${created} created, ${updated} updated, ${this.errors.length} errors`);
      
      // Send Slack notification
      await this.sendSlackNotification(result);
      
      return result;
      
    } catch (error) {
      this.error('Blog sync failed', error as Error);
      
      const result: BlogSyncResult = {
        success: false,
        processed,
        created,
        updated,
        errors: this.errors,
        logs: this.logs
      };
      
      await this.sendSlackNotification(result);
      
      return result;
    }
  }
}

// Factory function for creating sync service
export function createBlogSyncService(config: BlogSyncConfig): BlogSyncService {
  return new BlogSyncService(config);
}

// Helper function to create config from environment variables
export function getBlogSyncConfig(): BlogSyncConfig {
  const config = {
    seobotApiKey: process.env.SEOBOT_API_KEY!,
    gitbookToken: process.env.GITBOOK_TOKEN!,
    gitbookSpaceId: process.env.GITBOOK_SPACE_ID!,
    gitbookBlogParentId: process.env.GITBOOK_BLOG_PARENT_ID!,
    slackWebhookUrl: process.env.SLACK_WEBHOOK_URL
  };

  // Validate required config
  const required = ['seobotApiKey', 'gitbookToken', 'gitbookSpaceId', 'gitbookBlogParentId'];
  const missing = required.filter(key => !config[key as keyof BlogSyncConfig]);
  
  if (missing.length > 0) {
    throw new Error(`Missing required environment variables: ${missing.join(', ')}`);
  }

  return config;
}
